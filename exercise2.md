# Архитектура #
## Уровни веб-приложения: ##  

Существует четыре общих уровня веб-приложений:

- Уровень представления (PL)
- Уровень обслуживания данных (DSL)
- Уровень бизнес-логики (BLL)
- Уровень доступа к данным (DAL)
## За что отвечает каждый из уровней веб-приложения: ##

**Уровень представления**
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.

**Уровень службы данных**
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.

**Слой бизнес-логики**
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.

**Уровень доступа к данным**
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.

## Монолитная и микросервисная архитектура веб-приложений
**Монолитная архитектура** является классическим подходом к разработке, когда приложение построено как один цельный продукт и упаковано в виде одного WAR-файла или Node с одной точкой входа. При монолитной архитектуре все стандартные модули, пользовательский интерфейс (UI), бизнес-логика и дата-слой выступают как единый сервис. Компоненты программного обеспечения взаимосвязаны и взаимозависимы, что помогает программному обеспечению быть самодостаточным. Монолитная архитектура предполагает, что при обработке пользовательского запроса система прогоняет его по всем уровням.

**Преимущества:**
- **Простое развертывание**. Использование одного исполняемого файла или каталога упрощает развертывание.
- **Разработка**. Приложение легче разрабатывать, когда оно создано с использованием одной базы кода.
- **Производительность**. В централизованной базе кода и репозитории один интерфейс API часто может выполнять ту функцию, которую при работе с микросервисами выполняют многочисленные API.
- **Упрощенное тестирование**. Монолитное приложение представляет собой единый централизованный модуль, поэтому сквозное тестирование можно проводить быстрее, чем при использовании распределенного приложения.
- **Удобная отладка**. Весь код находится в одном месте, благодаря чему становится легче выполнять запросы и находить проблемы.

**Недостатки:**
- **Снижение скорости разработки**. Большое монолитное приложение усложняет и замедляет разработку.
- **Масштабируемость**. Невозможно масштабировать отдельные компоненты.
- **Надежность**. Ошибка в одном модуле может повлиять на доступность всего приложения.
- **Препятствия для внедрения технологий**. Любые изменения в инфраструктуре или языке разработки влияют на приложение целиком, что зачастую приводит к увеличению стоимости и временных затрат.
- **Недостаточная гибкость**. Возможности монолитных приложений ограничены используемыми технологиями.
- **Развертывание**. При внесении небольшого изменения потребуется повторное развертывание всего монолитного приложения.

**Микросервисная архитектура** - это тип сервисно-ориентированной архитектуры программного обеспечения, ориентированный на создание ряда автономных компонентов, составляющих приложение. У каждого компонента своя собственная логика и база данных, а их взаимодействие осуществляется через сеть по протоколонезависимой технологии. Приложение на базе микросервисной архитектуры дает больше возможностей, однако устроено оно сложнее.

**Преимущества:**
- **Высокая отказоустойчивость**: при падении одного из сервисов, все остальные остаются в строю. Таким образом, неполадки в отдельных сервисах не помешают всему рабочему процессу.
- **Гибкость**: можно попробовать внедрить новую технологию. Это будет значительно быстрее и, при неудаче, откатить изменения просто. Меняя локально один из сервисов, мы не рискуем всей системой и время, требующееся для изменений, меньше.
- **Простота**: чем меньше кода (а каждый отдельный сервис представляет собой цельную систему, поэтому не нужно разбираться в огромном количестве деталей, не касающихся данной конкретной функции), тем проще программистам разобраться, что и как работает. К тому же, на это уйдет меньше времени.
- **Лёгкость выведения написанного кода в работу**. Небольшое количество кода обеспечивает быстрый деплой.
- **Масштабируемость**. Самые необходимые и нужные сервисы можно дополнить и расширить, когда появится такая необходимость. Вся система при этом остается прежней.

**Недостатки:**
- Сообщение между самими сервисами сложное. Так как каждый функциональный элемент изолирован, требуется особая тщательность при построении между ними грамотной коммуникации, ведь им в любом случае придётся обмениваться запросами и ответами друг с другом. С увеличением количества сервисов сложность в построении их сообщения будет расти.
- Рост числа сервисов также влечет за собой и рост числа баз данных, с которыми эти сервисы соотносятся, так как, в отличие от монолитной архитектуры, микросервисы используют не одну общую базу данных.
- Сложность тестирования выражается в том, что сначала нужно отдельно разбираться с каждым сервисом, а потом тестировать корректное взаимодействие его с другими микросервисами.
- Микросервисы хуже подходят для использования внутри отдельных организаций, для них они могут оказаться неоправданно сложными в применении, в то время как для массовых интернет-сервисов они подходят отлично.
## Различия между монолитной и микросервисной архитектурой:
**Процесс разработки**

Начать работу проще с *монолитным приложением*, так как не требуется предварительное планирование. Вы можете просто создать базовый вариант и добавлять модули кода по мере необходимости. Однако со временем такое приложение становится сложным, и любые обновления в нем затрудняются.

*Архитектура микросервисов* требует все тщательно продумать еще до того, как начинать разработку. Сначала нужно определить, какие функциональные возможности могут работать независимо друг от друга, и создать согласованный проект API. Первоначальная координация значительно повышает эффективность при дальнейшем обслуживании кода. Вы сможете быстрее вносить изменения и находить ошибки. Также со временем возрастает возможность повторного использования кода. 

**Развертывание**

Развертывание *монолитных приложений* проще, чем развертывание *микросервисов*. Разработчики устанавливают всю базу кода и зависимости для приложения в одной среде. 

Развертывание приложений на основе *микросервисов* намного сложнее, поскольку каждый микросервис представляет собой независимо развертываемый пакет программного обеспечения.

**Отладка**

 При отладке *монолитной архитектуры* разработчик может отслеживать перемещение данных или изучать поведение, непосредственно анализируя кода в одной среде программирования. Для выявления проблем в коде с *микросервисной архитектурой* придется анализировать сразу несколько слабо связанных сервисов. 

Отладка *микросервисных приложений* может оказаться более сложной задачей, поскольку затронутые микросервисы могут разрабатываться разными людьми и командами. Это означает, что для отладки потребуется координировать тесты, обсуждения и сбор отзывов между многими членами команды, а это дополнительные затраты времени и ресурсов. 

**Модификации**

Небольшое изменение в одной части *монолитного* приложения влияет на многие функции программного обеспечения, поскольку весь его код тесно связан. Кроме того, любые изменения в монолитном приложении приводят к тому, что всю систему нужно повторно тестировать и развертывать на сервере.

Подход, основанный на *микросервисах*, наоборот, очень гибок. Вносить изменения в такое приложение намного проще. Разработчикам не нужно модифицировать все сервисы, достаточно лишь изменить конкретные функции. 

**Масштабирование**

При масштабировании *монолитных* приложений возникает целый ряд проблем. *Монолитная архитектура* объединяет все функциональные возможности в одной базе кода, поэтому масштабировать при изменении требований придется все приложение сразу. Например, если из-за увеличения трафика снижается производительность коммуникационных функций приложения, придется предоставлять дополнительные вычислительные ресурсы для всего монолитного приложения. Это приводит к нерациональному использованию ресурсов, поскольку не все части приложения работают на пиковой мощности.

*Архитектура микросервисов* поддерживает распределенные системы. Каждый программный компонент в распределенной системе получает собственные вычислительные ресурсы. Ресурсы для любого из них можно масштабировать независимо от других, в зависимости от текущих и прогнозируемых потребностей. Например, вы можете выделить больше ресурсов только службе определения географического местоположения, но не остальным частям системы.

## Существует несколько причин, почему не все веб-приложения построены на микросервисной архитектуре:

1. **Сложность:** Разработка и поддержка микросервисной архитектуры может быть сложной задачей. Это требует наличия экспертов, способных эффективно разрабатывать, тестировать и масштабировать отдельные сервисы.

2. **Избыточность:** В случае микросервисной архитектуры каждый сервис должен иметь свою собственную инфраструктуру и базу данных. Это может привести к избыточности, особенно для небольших приложений, где такие сложные системы не требуются.

3. **Накладные расходы:** Микросервисная архитектура может потребовать больше ресурсов, таких как память и процессорное время, чем монолитная архитектура. Это может повлиять на производительность и требования к инфраструктуре.

4. **Комплексность управления:** Управление множеством сервисов и их взаимодействием может быть сложным. Требуется эффективное мониторинговое и управление системой, чтобы обеспечить стабильность и отказоустойчивость.

5. **Необходимость:** Некоторые веб-приложения просты по своей природе и не требуют сложной архитектуры с микросервисами. Монолитная архитектура может быть достаточной для таких случаев.

В конечном итоге, выбор архитектуры зависит от требований и особенностей конкретного приложения. Микросервисная архитектура имеет свои преимущества, но также сопряжена с дополнительными сложностями и издержками.

## Особенности тестирования монолитных и микросервисных веб-приложений:

1. **Монолитные приложения:**
   - *Тестирование функциональности:* В монолитных приложениях тестирование функциональности может быть более простым, так как все компоненты находятся в одном месте.
   - *Тестирование интеграции:* В монолитных приложениях интеграционное тестирование может быть сложным, так как различные компоненты могут быть сильно связаны друг с другом.
   - *Нагрузочное тестирование:* Нагрузочное тестирование может быть сложным из-за ограниченных ресурсов и возможности горизонтального масштабирования.


2. **Микросервисные приложения:**
   - *Тестирование функциональности:* В микросервисных приложениях каждый сервис может быть протестирован отдельно, что облегчает обнаружение и исправление ошибок.
   - *Тестирование интеграции:* Интеграционное тестирование микросервисных приложений может быть сложным из-за большого количества сервисов и возможных комбинаций взаимодействия между ними.
   - *Нагрузочное тестирование:* Микросервисные приложения могут быть легче масштабированы горизонтально, что облегчает нагрузочное тестирование.

В обоих случаях важно иметь хорошо организованные и автоматизированные тестовые сценарии, а также мониторинг и отладку для обнаружения и исправления проблем.